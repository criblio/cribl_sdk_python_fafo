// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type SearchQueryEarliest2Type string

const (
	SearchQueryEarliest2TypeStr    SearchQueryEarliest2Type = "str"
	SearchQueryEarliest2TypeNumber SearchQueryEarliest2Type = "number"
)

type SearchQueryEarliest2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryEarliest2Type
}

func CreateSearchQueryEarliest2Str(str string) SearchQueryEarliest2 {
	typ := SearchQueryEarliest2TypeStr

	return SearchQueryEarliest2{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryEarliest2Number(number float64) SearchQueryEarliest2 {
	typ := SearchQueryEarliest2TypeNumber

	return SearchQueryEarliest2{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryEarliest2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryEarliest2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryEarliest2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryEarliest2", string(data))
}

func (u SearchQueryEarliest2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryEarliest2: all fields are null")
}

type SearchQueryLatest2Type string

const (
	SearchQueryLatest2TypeStr    SearchQueryLatest2Type = "str"
	SearchQueryLatest2TypeNumber SearchQueryLatest2Type = "number"
)

type SearchQueryLatest2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryLatest2Type
}

func CreateSearchQueryLatest2Str(str string) SearchQueryLatest2 {
	typ := SearchQueryLatest2TypeStr

	return SearchQueryLatest2{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryLatest2Number(number float64) SearchQueryLatest2 {
	typ := SearchQueryLatest2TypeNumber

	return SearchQueryLatest2{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryLatest2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryLatest2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryLatest2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryLatest2", string(data))
}

func (u SearchQueryLatest2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryLatest2: all fields are null")
}

type TypeMetric string

const (
	TypeMetricMetric TypeMetric = "metric"
)

func (e TypeMetric) ToPointer() *TypeMetric {
	return &e
}
func (e *TypeMetric) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "metric":
		*e = TypeMetric(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeMetric: %v", v)
	}
}

type SearchQueryMetric struct {
	Earliest     SearchQueryEarliest2   `json:"earliest"`
	IsMonitoring *bool                  `json:"isMonitoring,omitempty"`
	Latest       SearchQueryLatest2     `json:"latest"`
	Queries      []PanelQueryDefinition `json:"queries"`
	Timezone     *string                `json:"timezone,omitempty"`
	Type         TypeMetric             `json:"type"`
}

func (o *SearchQueryMetric) GetEarliest() SearchQueryEarliest2 {
	if o == nil {
		return SearchQueryEarliest2{}
	}
	return o.Earliest
}

func (o *SearchQueryMetric) GetIsMonitoring() *bool {
	if o == nil {
		return nil
	}
	return o.IsMonitoring
}

func (o *SearchQueryMetric) GetLatest() SearchQueryLatest2 {
	if o == nil {
		return SearchQueryLatest2{}
	}
	return o.Latest
}

func (o *SearchQueryMetric) GetQueries() []PanelQueryDefinition {
	if o == nil {
		return []PanelQueryDefinition{}
	}
	return o.Queries
}

func (o *SearchQueryMetric) GetTimezone() *string {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *SearchQueryMetric) GetType() TypeMetric {
	if o == nil {
		return TypeMetric("")
	}
	return o.Type
}

type SearchQuery struct {
}

type TypeValues string

const (
	TypeValuesValues TypeValues = "values"
)

func (e TypeValues) ToPointer() *TypeValues {
	return &e
}
func (e *TypeValues) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "values":
		*e = TypeValues(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeValues: %v", v)
	}
}

type SearchQueryValues struct {
	Type   TypeValues `json:"type"`
	Values []string   `json:"values"`
}

func (o *SearchQueryValues) GetType() TypeValues {
	if o == nil {
		return TypeValues("")
	}
	return o.Type
}

func (o *SearchQueryValues) GetValues() []string {
	if o == nil {
		return []string{}
	}
	return o.Values
}

type SearchQueryEarliest1Type string

const (
	SearchQueryEarliest1TypeStr    SearchQueryEarliest1Type = "str"
	SearchQueryEarliest1TypeNumber SearchQueryEarliest1Type = "number"
)

type SearchQueryEarliest1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryEarliest1Type
}

func CreateSearchQueryEarliest1Str(str string) SearchQueryEarliest1 {
	typ := SearchQueryEarliest1TypeStr

	return SearchQueryEarliest1{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryEarliest1Number(number float64) SearchQueryEarliest1 {
	typ := SearchQueryEarliest1TypeNumber

	return SearchQueryEarliest1{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryEarliest1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryEarliest1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryEarliest1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryEarliest1", string(data))
}

func (u SearchQueryEarliest1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryEarliest1: all fields are null")
}

type SearchQueryLatest1Type string

const (
	SearchQueryLatest1TypeStr    SearchQueryLatest1Type = "str"
	SearchQueryLatest1TypeNumber SearchQueryLatest1Type = "number"
)

type SearchQueryLatest1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchQueryLatest1Type
}

func CreateSearchQueryLatest1Str(str string) SearchQueryLatest1 {
	typ := SearchQueryLatest1TypeStr

	return SearchQueryLatest1{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchQueryLatest1Number(number float64) SearchQueryLatest1 {
	typ := SearchQueryLatest1TypeNumber

	return SearchQueryLatest1{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchQueryLatest1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = SearchQueryLatest1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = SearchQueryLatest1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryLatest1", string(data))
}

func (u SearchQueryLatest1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryLatest1: all fields are null")
}

type TypeInline string

const (
	TypeInlineInline TypeInline = "inline"
)

func (e TypeInline) ToPointer() *TypeInline {
	return &e
}
func (e *TypeInline) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inline":
		*e = TypeInline(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeInline: %v", v)
	}
}

type SearchQueryInline struct {
	Earliest       SearchQueryEarliest1 `json:"earliest"`
	Latest         SearchQueryLatest1   `json:"latest"`
	ParentSearchID *string              `json:"parentSearchId,omitempty"`
	Query          string               `json:"query"`
	SampleRate     *float64             `json:"sampleRate,omitempty"`
	Timezone       *string              `json:"timezone,omitempty"`
	Type           TypeInline           `json:"type"`
}

func (o *SearchQueryInline) GetEarliest() SearchQueryEarliest1 {
	if o == nil {
		return SearchQueryEarliest1{}
	}
	return o.Earliest
}

func (o *SearchQueryInline) GetLatest() SearchQueryLatest1 {
	if o == nil {
		return SearchQueryLatest1{}
	}
	return o.Latest
}

func (o *SearchQueryInline) GetParentSearchID() *string {
	if o == nil {
		return nil
	}
	return o.ParentSearchID
}

func (o *SearchQueryInline) GetQuery() string {
	if o == nil {
		return ""
	}
	return o.Query
}

func (o *SearchQueryInline) GetSampleRate() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRate
}

func (o *SearchQueryInline) GetTimezone() *string {
	if o == nil {
		return nil
	}
	return o.Timezone
}

func (o *SearchQueryInline) GetType() TypeInline {
	if o == nil {
		return TypeInline("")
	}
	return o.Type
}

type TypeSaved string

const (
	TypeSavedSaved TypeSaved = "saved"
)

func (e TypeSaved) ToPointer() *TypeSaved {
	return &e
}
func (e *TypeSaved) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "saved":
		*e = TypeSaved(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeSaved: %v", v)
	}
}

type SearchQuerySaved struct {
	Query   *string             `json:"query,omitempty"`
	QueryID string              `json:"queryId"`
	RunMode *SavesSearchRunMode `json:"runMode,omitempty"`
	Type    TypeSaved           `json:"type"`
}

func (o *SearchQuerySaved) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *SearchQuerySaved) GetQueryID() string {
	if o == nil {
		return ""
	}
	return o.QueryID
}

func (o *SearchQuerySaved) GetRunMode() *SavesSearchRunMode {
	if o == nil {
		return nil
	}
	return o.RunMode
}

func (o *SearchQuerySaved) GetType() TypeSaved {
	if o == nil {
		return TypeSaved("")
	}
	return o.Type
}

type SearchQueryUnionType string

const (
	SearchQueryUnionTypeSearchQuerySaved  SearchQueryUnionType = "SearchQuery_Saved"
	SearchQueryUnionTypeSearchQueryInline SearchQueryUnionType = "SearchQuery_Inline"
	SearchQueryUnionTypeSearchQueryValues SearchQueryUnionType = "SearchQuery_Values"
	SearchQueryUnionTypeSearchQuery       SearchQueryUnionType = "SearchQuery"
	SearchQueryUnionTypeSearchQueryMetric SearchQueryUnionType = "SearchQuery_Metric"
)

type SearchQueryUnion struct {
	SearchQuerySaved  *SearchQuerySaved  `queryParam:"inline"`
	SearchQueryInline *SearchQueryInline `queryParam:"inline"`
	SearchQueryValues *SearchQueryValues `queryParam:"inline"`
	SearchQuery       *SearchQuery       `queryParam:"inline"`
	SearchQueryMetric *SearchQueryMetric `queryParam:"inline"`

	Type SearchQueryUnionType
}

func CreateSearchQueryUnionSearchQuerySaved(searchQuerySaved SearchQuerySaved) SearchQueryUnion {
	typ := SearchQueryUnionTypeSearchQuerySaved

	return SearchQueryUnion{
		SearchQuerySaved: &searchQuerySaved,
		Type:             typ,
	}
}

func CreateSearchQueryUnionSearchQueryInline(searchQueryInline SearchQueryInline) SearchQueryUnion {
	typ := SearchQueryUnionTypeSearchQueryInline

	return SearchQueryUnion{
		SearchQueryInline: &searchQueryInline,
		Type:              typ,
	}
}

func CreateSearchQueryUnionSearchQueryValues(searchQueryValues SearchQueryValues) SearchQueryUnion {
	typ := SearchQueryUnionTypeSearchQueryValues

	return SearchQueryUnion{
		SearchQueryValues: &searchQueryValues,
		Type:              typ,
	}
}

func CreateSearchQueryUnionSearchQuery(searchQuery SearchQuery) SearchQueryUnion {
	typ := SearchQueryUnionTypeSearchQuery

	return SearchQueryUnion{
		SearchQuery: &searchQuery,
		Type:        typ,
	}
}

func CreateSearchQueryUnionSearchQueryMetric(searchQueryMetric SearchQueryMetric) SearchQueryUnion {
	typ := SearchQueryUnionTypeSearchQueryMetric

	return SearchQueryUnion{
		SearchQueryMetric: &searchQueryMetric,
		Type:              typ,
	}
}

func (u *SearchQueryUnion) UnmarshalJSON(data []byte) error {

	var searchQuery SearchQuery = SearchQuery{}
	if err := utils.UnmarshalJSON(data, &searchQuery, "", true, true); err == nil {
		u.SearchQuery = &searchQuery
		u.Type = SearchQueryUnionTypeSearchQuery
		return nil
	}

	var searchQueryValues SearchQueryValues = SearchQueryValues{}
	if err := utils.UnmarshalJSON(data, &searchQueryValues, "", true, true); err == nil {
		u.SearchQueryValues = &searchQueryValues
		u.Type = SearchQueryUnionTypeSearchQueryValues
		return nil
	}

	var searchQuerySaved SearchQuerySaved = SearchQuerySaved{}
	if err := utils.UnmarshalJSON(data, &searchQuerySaved, "", true, true); err == nil {
		u.SearchQuerySaved = &searchQuerySaved
		u.Type = SearchQueryUnionTypeSearchQuerySaved
		return nil
	}

	var searchQueryMetric SearchQueryMetric = SearchQueryMetric{}
	if err := utils.UnmarshalJSON(data, &searchQueryMetric, "", true, true); err == nil {
		u.SearchQueryMetric = &searchQueryMetric
		u.Type = SearchQueryUnionTypeSearchQueryMetric
		return nil
	}

	var searchQueryInline SearchQueryInline = SearchQueryInline{}
	if err := utils.UnmarshalJSON(data, &searchQueryInline, "", true, true); err == nil {
		u.SearchQueryInline = &searchQueryInline
		u.Type = SearchQueryUnionTypeSearchQueryInline
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchQueryUnion", string(data))
}

func (u SearchQueryUnion) MarshalJSON() ([]byte, error) {
	if u.SearchQuerySaved != nil {
		return utils.MarshalJSON(u.SearchQuerySaved, "", true)
	}

	if u.SearchQueryInline != nil {
		return utils.MarshalJSON(u.SearchQueryInline, "", true)
	}

	if u.SearchQueryValues != nil {
		return utils.MarshalJSON(u.SearchQueryValues, "", true)
	}

	if u.SearchQuery != nil {
		return utils.MarshalJSON(u.SearchQuery, "", true)
	}

	if u.SearchQueryMetric != nil {
		return utils.MarshalJSON(u.SearchQueryMetric, "", true)
	}

	return nil, errors.New("could not marshal union type SearchQueryUnion: all fields are null")
}
