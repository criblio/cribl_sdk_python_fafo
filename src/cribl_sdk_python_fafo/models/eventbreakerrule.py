"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .eventbreakerrulefields import (
    EventBreakerRuleFields,
    EventBreakerRuleFieldsTypedDict,
)
from .parsermode import ParserMode
from cribl_sdk_python_fafo.types import BaseModel
from enum import Enum
import pydantic
from typing import List, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class TypeKvp(str, Enum):
    KVP = "kvp"


class ParserKvpTypedDict(TypedDict):
    mode: ParserMode
    src_field: str
    type: TypeKvp
    allowed_key_chars: NotRequired[bool]
    allowed_value_chars: NotRequired[List[str]]
    clean_fields: NotRequired[List[str]]
    delim_char: NotRequired[str]
    dst_field: NotRequired[str]
    escape_char: NotRequired[str]
    field_filter_expr: NotRequired[str]
    fields: NotRequired[List[str]]
    keep: NotRequired[List[str]]
    null_value: NotRequired[str]
    quote_char: NotRequired[str]
    remove: NotRequired[List[str]]


class ParserKvp(BaseModel):
    mode: ParserMode

    src_field: Annotated[str, pydantic.Field(alias="srcField")]

    type: TypeKvp

    allowed_key_chars: Annotated[
        Optional[bool], pydantic.Field(alias="allowedKeyChars")
    ] = None

    allowed_value_chars: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedValueChars")
    ] = None

    clean_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="cleanFields")
    ] = None

    delim_char: Annotated[Optional[str], pydantic.Field(alias="delimChar")] = None

    dst_field: Annotated[Optional[str], pydantic.Field(alias="dstField")] = None

    escape_char: Annotated[Optional[str], pydantic.Field(alias="escapeChar")] = None

    field_filter_expr: Annotated[
        Optional[str], pydantic.Field(alias="fieldFilterExpr")
    ] = None

    fields: Optional[List[str]] = None

    keep: Optional[List[str]] = None

    null_value: Annotated[Optional[str], pydantic.Field(alias="nullValue")] = None

    quote_char: Annotated[Optional[str], pydantic.Field(alias="quoteChar")] = None

    remove: Optional[List[str]] = None


class TypeJSON(str, Enum):
    JSON = "json"


class ParserJSONTypedDict(TypedDict):
    mode: ParserMode
    src_field: str
    type: TypeJSON
    clean_fields: NotRequired[List[str]]
    dst_field: NotRequired[str]
    field_filter_expr: NotRequired[str]
    fields: NotRequired[List[str]]
    keep: NotRequired[List[str]]
    remove: NotRequired[List[str]]


class ParserJSON(BaseModel):
    mode: ParserMode

    src_field: Annotated[str, pydantic.Field(alias="srcField")]

    type: TypeJSON

    clean_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="cleanFields")
    ] = None

    dst_field: Annotated[Optional[str], pydantic.Field(alias="dstField")] = None

    field_filter_expr: Annotated[
        Optional[str], pydantic.Field(alias="fieldFilterExpr")
    ] = None

    fields: Optional[List[str]] = None

    keep: Optional[List[str]] = None

    remove: Optional[List[str]] = None


class PatternListTypedDict(TypedDict):
    pattern: str


class PatternList(BaseModel):
    pattern: str


class TypeGrok(str, Enum):
    GROK = "grok"


class ParserGrokTypedDict(TypedDict):
    mode: ParserMode
    src_field: str
    type: TypeGrok
    dst_field: NotRequired[str]
    pattern: NotRequired[str]
    pattern_list: NotRequired[List[PatternListTypedDict]]
    source: NotRequired[str]


class ParserGrok(BaseModel):
    mode: ParserMode

    src_field: Annotated[str, pydantic.Field(alias="srcField")]

    type: TypeGrok

    dst_field: Annotated[Optional[str], pydantic.Field(alias="dstField")] = None

    pattern: Optional[str] = None

    pattern_list: Annotated[
        Optional[List[PatternList]], pydantic.Field(alias="patternList")
    ] = None

    source: Optional[str] = None


class ParserType(str, Enum):
    CLF = "clf"
    CSV = "csv"
    DELIM = "delim"
    ELFF = "elff"


class ParserTypedDict(TypedDict):
    mode: ParserMode
    src_field: str
    type: ParserType
    allowed_key_chars: NotRequired[bool]
    allowed_value_chars: NotRequired[List[str]]
    clean_fields: NotRequired[List[str]]
    delim_char: NotRequired[str]
    dst_field: NotRequired[str]
    escape_char: NotRequired[str]
    field_filter_expr: NotRequired[str]
    fields: NotRequired[List[str]]
    keep: NotRequired[List[str]]
    null_value: NotRequired[str]
    quote_char: NotRequired[str]
    remove: NotRequired[List[str]]


class Parser(BaseModel):
    mode: ParserMode

    src_field: Annotated[str, pydantic.Field(alias="srcField")]

    type: ParserType

    allowed_key_chars: Annotated[
        Optional[bool], pydantic.Field(alias="allowedKeyChars")
    ] = None

    allowed_value_chars: Annotated[
        Optional[List[str]], pydantic.Field(alias="allowedValueChars")
    ] = None

    clean_fields: Annotated[
        Optional[List[str]], pydantic.Field(alias="cleanFields")
    ] = None

    delim_char: Annotated[Optional[str], pydantic.Field(alias="delimChar")] = None

    dst_field: Annotated[Optional[str], pydantic.Field(alias="dstField")] = None

    escape_char: Annotated[Optional[str], pydantic.Field(alias="escapeChar")] = None

    field_filter_expr: Annotated[
        Optional[str], pydantic.Field(alias="fieldFilterExpr")
    ] = None

    fields: Optional[List[str]] = None

    keep: Optional[List[str]] = None

    null_value: Annotated[Optional[str], pydantic.Field(alias="nullValue")] = None

    quote_char: Annotated[Optional[str], pydantic.Field(alias="quoteChar")] = None

    remove: Optional[List[str]] = None


ParserUnionTypedDict = TypeAliasType(
    "ParserUnionTypedDict",
    Union[
        ParserGrokTypedDict, ParserJSONTypedDict, ParserTypedDict, ParserKvpTypedDict
    ],
)


ParserUnion = TypeAliasType(
    "ParserUnion", Union[ParserGrok, ParserJSON, Parser, ParserKvp]
)


class EventBreakerRuleTimestampType(str, Enum):
    AUTO = "auto"
    FORMAT = "format"
    CURRENT = "current"


class TimestampTypedDict(TypedDict):
    type: EventBreakerRuleTimestampType
    format_: NotRequired[str]
    length: NotRequired[float]


class Timestamp(BaseModel):
    type: EventBreakerRuleTimestampType

    format_: Annotated[Optional[str], pydantic.Field(alias="format")] = None

    length: Optional[float] = None


class TimestampTimezoneTypedDict(TypedDict):
    name: str
    offsets: List[float]
    untils: List[float]


class TimestampTimezone(BaseModel):
    name: str

    offsets: List[float]

    untils: List[float]


TimestampTimezoneUnionTypedDict = TypeAliasType(
    "TimestampTimezoneUnionTypedDict", Union[TimestampTimezoneTypedDict, str]
)


TimestampTimezoneUnion = TypeAliasType(
    "TimestampTimezoneUnion", Union[TimestampTimezone, str]
)


class EventBreakerRuleType(str, Enum):
    REGEX = "regex"
    TIMESTAMP = "timestamp"
    JSON = "json"
    CSV = "csv"
    JSON_ARRAY = "json_array"
    HEADER = "header"
    AWS_CLOUDTRAIL = "aws_cloudtrail"
    AWS_VPCFLOW = "aws_vpcflow"


class EventBreakerRuleTypedDict(TypedDict):
    condition: str
    max_event_bytes: float
    name: str
    timestamp: TimestampTypedDict
    timestamp_anchor_regex: str
    timestamp_timezone: TimestampTimezoneUnionTypedDict
    clean_fields: NotRequired[bool]
    delimiter: NotRequired[str]
    delimiter_regex: NotRequired[str]
    disabled: NotRequired[bool]
    escape_char: NotRequired[str]
    event_breaker_regex: NotRequired[str]
    fields: NotRequired[List[EventBreakerRuleFieldsTypedDict]]
    fields_line_regex: NotRequired[str]
    header_line_regex: NotRequired[str]
    index: NotRequired[float]
    json_array_field: NotRequired[str]
    json_extract_all: NotRequired[bool]
    json_time_field: NotRequired[str]
    null_field_val: NotRequired[str]
    parser: NotRequired[ParserUnionTypedDict]
    parser_enabled: NotRequired[bool]
    quote_char: NotRequired[str]
    should_use_data_raw: NotRequired[bool]
    time_field: NotRequired[str]
    timestamp_earliest: NotRequired[str]
    timestamp_latest: NotRequired[str]
    type: NotRequired[EventBreakerRuleType]


class EventBreakerRule(BaseModel):
    condition: str

    max_event_bytes: Annotated[float, pydantic.Field(alias="maxEventBytes")]

    name: str

    timestamp: Timestamp

    timestamp_anchor_regex: Annotated[str, pydantic.Field(alias="timestampAnchorRegex")]

    timestamp_timezone: Annotated[
        TimestampTimezoneUnion, pydantic.Field(alias="timestampTimezone")
    ]

    clean_fields: Annotated[Optional[bool], pydantic.Field(alias="cleanFields")] = None

    delimiter: Optional[str] = None

    delimiter_regex: Annotated[
        Optional[str], pydantic.Field(alias="delimiterRegex")
    ] = None

    disabled: Optional[bool] = None

    escape_char: Annotated[Optional[str], pydantic.Field(alias="escapeChar")] = None

    event_breaker_regex: Annotated[
        Optional[str], pydantic.Field(alias="eventBreakerRegex")
    ] = None

    fields: Optional[List[EventBreakerRuleFields]] = None

    fields_line_regex: Annotated[
        Optional[str], pydantic.Field(alias="fieldsLineRegex")
    ] = None

    header_line_regex: Annotated[
        Optional[str], pydantic.Field(alias="headerLineRegex")
    ] = None

    index: Optional[float] = None

    json_array_field: Annotated[
        Optional[str], pydantic.Field(alias="jsonArrayField")
    ] = None

    json_extract_all: Annotated[
        Optional[bool], pydantic.Field(alias="jsonExtractAll")
    ] = None

    json_time_field: Annotated[Optional[str], pydantic.Field(alias="jsonTimeField")] = (
        None
    )

    null_field_val: Annotated[Optional[str], pydantic.Field(alias="nullFieldVal")] = (
        None
    )

    parser: Optional[ParserUnion] = None

    parser_enabled: Annotated[Optional[bool], pydantic.Field(alias="parserEnabled")] = (
        None
    )

    quote_char: Annotated[Optional[str], pydantic.Field(alias="quoteChar")] = None

    should_use_data_raw: Annotated[
        Optional[bool], pydantic.Field(alias="shouldUseDataRaw")
    ] = None

    time_field: Annotated[Optional[str], pydantic.Field(alias="timeField")] = None

    timestamp_earliest: Annotated[
        Optional[str], pydantic.Field(alias="timestampEarliest")
    ] = None

    timestamp_latest: Annotated[
        Optional[str], pydantic.Field(alias="timestampLatest")
    ] = None

    type: Optional[EventBreakerRuleType] = None
