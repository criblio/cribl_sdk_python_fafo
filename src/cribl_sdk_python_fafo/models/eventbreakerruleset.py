"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from cribl_sdk_python_fafo.types import BaseModel
from enum import Enum
import pydantic
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Library(str, Enum):
    CUSTOM = "custom"
    CRIBL_CUSTOM = "cribl-custom"


class EventBreakerType(str, Enum):
    REGEX = "regex"
    JSON = "json"
    JSON_ARRAY = "json_array"
    HEADER = "header"
    TIMESTAMP = "timestamp"
    CSV = "csv"
    AWS_CLOUDTRAIL = "aws_cloudtrail"
    AWS_VPCFLOW = "aws_vpcflow"


class EventBreakerRulesetTimestampType(str, Enum):
    AUTO = "auto"
    FORMAT = "format"
    CURRENT = "current"


class EventBreakerRulesetTimestampFormatTypedDict(TypedDict):
    r"""Auto, manual format (strptime), or current time"""

    type: NotRequired[EventBreakerRulesetTimestampType]
    length: NotRequired[float]
    format_: NotRequired[str]


class EventBreakerRulesetTimestampFormat(BaseModel):
    r"""Auto, manual format (strptime), or current time"""

    type: Optional[EventBreakerRulesetTimestampType] = (
        EventBreakerRulesetTimestampType.AUTO
    )

    length: Optional[float] = 150

    format_: Annotated[Optional[str], pydantic.Field(alias="format")] = None


class EventBreakerRulesetFieldTypedDict(TypedDict):
    value: str
    r"""The JavaScript expression used to compute the field's value (can be constant)"""
    name: NotRequired[str]


class EventBreakerRulesetField(BaseModel):
    value: str
    r"""The JavaScript expression used to compute the field's value (can be constant)"""

    name: Optional[str] = None


class EventBreakerRulesetRuleTypedDict(TypedDict):
    name: str
    timestamp: EventBreakerRulesetTimestampFormatTypedDict
    r"""Auto, manual format (strptime), or current time"""
    condition: NotRequired[str]
    r"""JavaScript expression applied to the beginning of a file or object, to determine whether the rule applies to all contained events."""
    type: NotRequired[EventBreakerType]
    timestamp_anchor_regex: NotRequired[str]
    r"""The regex to match before attempting timestamp extraction. Use $ (end-of-string anchor) to prevent extraction."""
    timestamp_timezone: NotRequired[str]
    r"""Timezone to assign to timestamps without timezone info"""
    timestamp_earliest: NotRequired[str]
    r"""The earliest timestamp value allowed relative to now. Example: -42years. Parsed values prior to this date will be set to current time."""
    timestamp_latest: NotRequired[str]
    r"""The latest timestamp value allowed relative to now. Example: +42days. Parsed values after this date will be set to current time."""
    max_event_bytes: NotRequired[float]
    r"""The maximum number of bytes in an event before it is flushed to the pipelines"""
    fields: NotRequired[List[EventBreakerRulesetFieldTypedDict]]
    r"""Key-value pairs to be added to each event"""
    disabled: NotRequired[bool]
    r"""Disable this breaker rule (enabled by default)"""
    parser_enabled: NotRequired[bool]
    should_use_data_raw: NotRequired[bool]
    r"""Enable to set an internal field on events indicating that the field in the data called _raw should be used. This can be useful for post processors that want to use that field for event._raw, instead of replacing it with the actual raw event."""


class EventBreakerRulesetRule(BaseModel):
    name: str

    timestamp: EventBreakerRulesetTimestampFormat
    r"""Auto, manual format (strptime), or current time"""

    condition: Optional[str] = "true"
    r"""JavaScript expression applied to the beginning of a file or object, to determine whether the rule applies to all contained events."""

    type: Optional[EventBreakerType] = EventBreakerType.REGEX

    timestamp_anchor_regex: Annotated[
        Optional[str], pydantic.Field(alias="timestampAnchorRegex")
    ] = "/^/"
    r"""The regex to match before attempting timestamp extraction. Use $ (end-of-string anchor) to prevent extraction."""

    timestamp_timezone: Annotated[
        Optional[str], pydantic.Field(alias="timestampTimezone")
    ] = "local"
    r"""Timezone to assign to timestamps without timezone info"""

    timestamp_earliest: Annotated[
        Optional[str], pydantic.Field(alias="timestampEarliest")
    ] = "-420weeks"
    r"""The earliest timestamp value allowed relative to now. Example: -42years. Parsed values prior to this date will be set to current time."""

    timestamp_latest: Annotated[
        Optional[str], pydantic.Field(alias="timestampLatest")
    ] = "+1week"
    r"""The latest timestamp value allowed relative to now. Example: +42days. Parsed values after this date will be set to current time."""

    max_event_bytes: Annotated[
        Optional[float], pydantic.Field(alias="maxEventBytes")
    ] = 51200
    r"""The maximum number of bytes in an event before it is flushed to the pipelines"""

    fields: Optional[List[EventBreakerRulesetField]] = None
    r"""Key-value pairs to be added to each event"""

    disabled: Optional[bool] = False
    r"""Disable this breaker rule (enabled by default)"""

    parser_enabled: Annotated[Optional[bool], pydantic.Field(alias="parserEnabled")] = (
        False
    )

    should_use_data_raw: Annotated[
        Optional[bool], pydantic.Field(alias="shouldUseDataRaw")
    ] = False
    r"""Enable to set an internal field on events indicating that the field in the data called _raw should be used. This can be useful for post processors that want to use that field for event._raw, instead of replacing it with the actual raw event."""


class EventBreakerRulesetTypedDict(TypedDict):
    id: str
    lib: NotRequired[Library]
    description: NotRequired[str]
    tags: NotRequired[str]
    min_raw_length: NotRequired[float]
    r"""The  minimum number of characters in _raw to determine which rule to use"""
    rules: NotRequired[List[EventBreakerRulesetRuleTypedDict]]
    r"""A list of rules that will be applied, in order, to the input data stream"""


class EventBreakerRuleset(BaseModel):
    id: str

    lib: Optional[Library] = Library.CUSTOM

    description: Optional[str] = None

    tags: Optional[str] = None

    min_raw_length: Annotated[Optional[float], pydantic.Field(alias="minRawLength")] = (
        256
    )
    r"""The  minimum number of characters in _raw to determine which rule to use"""

    rules: Optional[List[EventBreakerRulesetRule]] = None
    r"""A list of rules that will be applied, in order, to the input data stream"""
