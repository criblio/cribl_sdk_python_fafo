// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type MaxType string

const (
	MaxTypeStr    MaxType = "str"
	MaxTypeNumber MaxType = "number"
)

type Max struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type MaxType
}

func CreateMaxStr(str string) Max {
	typ := MaxTypeStr

	return Max{
		Str:  &str,
		Type: typ,
	}
}

func CreateMaxNumber(number float64) Max {
	typ := MaxTypeNumber

	return Max{
		Number: &number,
		Type:   typ,
	}
}

func (u *Max) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MaxTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = MaxTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Max", string(data))
}

func (u Max) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type Max: all fields are null")
}

type MinType string

const (
	MinTypeStr    MinType = "str"
	MinTypeNumber MinType = "number"
)

type Min struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type MinType
}

func CreateMinStr(str string) Min {
	typ := MinTypeStr

	return Min{
		Str:  &str,
		Type: typ,
	}
}

func CreateMinNumber(number float64) Min {
	typ := MinTypeNumber

	return Min{
		Number: &number,
		Type:   typ,
	}
}

func (u *Min) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = MinTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = MinTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Min", string(data))
}

func (u Min) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type Min: all fields are null")
}

type Field struct {
	Buckets       []Bucket   `json:"buckets"`
	Count         float64    `json:"count"`
	CountDistinct float64    `json:"countDistinct"`
	CountNull     float64    `json:"countNull"`
	Max           *Max       `json:"max,omitempty"`
	Mean          *float64   `json:"mean,omitempty"`
	Min           *Min       `json:"min,omitempty"`
	Name          string     `json:"name"`
	Stdev         *float64   `json:"stdev,omitempty"`
	TopValues     []TopValue `json:"topValues"`
	Type          FieldType  `json:"type"`
}

func (o *Field) GetBuckets() []Bucket {
	if o == nil {
		return []Bucket{}
	}
	return o.Buckets
}

func (o *Field) GetCount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Count
}

func (o *Field) GetCountDistinct() float64 {
	if o == nil {
		return 0.0
	}
	return o.CountDistinct
}

func (o *Field) GetCountNull() float64 {
	if o == nil {
		return 0.0
	}
	return o.CountNull
}

func (o *Field) GetMax() *Max {
	if o == nil {
		return nil
	}
	return o.Max
}

func (o *Field) GetMean() *float64 {
	if o == nil {
		return nil
	}
	return o.Mean
}

func (o *Field) GetMin() *Min {
	if o == nil {
		return nil
	}
	return o.Min
}

func (o *Field) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Field) GetStdev() *float64 {
	if o == nil {
		return nil
	}
	return o.Stdev
}

func (o *Field) GetTopValues() []TopValue {
	if o == nil {
		return []TopValue{}
	}
	return o.TopValues
}

func (o *Field) GetType() FieldType {
	if o == nil {
		return FieldType("")
	}
	return o.Type
}
